<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title> Hooks </title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="../../Assets/stylesPages.css">
  <script src="../../Assets/scriptPages.js"></script>
</head>

<body>
  <h1> Hooks </h1>
  <p> Updated ( 2022-05-01 / 2022-11-21 / 2024-01-22 )</p>
  <p class="sitenav"> <a href="../../index.html" title="home">MySite></a>
    <a href="../index.html" title="Learn WebDesign">React></a> Hooks
  </p>
  <br>
  <details class="example" id="notes">
    <summary> Notes :</summary>
    <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
  </details>
  <h2 style="color:green;"><u> Useful Links : </u></h2>
  <p><a href="https://react.dev/reference/react/hooks" target="_blank">React Hook Reference </a></p>
  <h2 style="color:green;"><u> Remember This : </u></h2>

  <h2 style="color:green;"><u> Description and Demonstration : </u></h2>
  <p> - hooks are supported from React version <b>16.8</b> </p>
  <p> - Hook rules: </p>
  <p style="text-indent:25px;"> - only call a hook directly from the component (or from a custom hooks) <u>(ex: never call a hook from an <mark>if</mark> or <mark>loop</mark> statement or from a custom JavaScript function)</u> </p>
  <!----------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> Custom Hooks </h2>
  <p> - we can create our own hook, simply create a function where we use built-in hooks (must be prefixed with <mark>use</mark> (ex: <mark>use<strong>MyHook</strong></mark>)) </p>
  <pre class="syntax">
    function use<strong>MyHook</strong>() { }
  </pre>
  <details class="example">
    <summary> Example : </summary>
    <pre>
    import React, { useState, useEffect } from 'react';
    import useFetchData from './fetchHook';
    
    function SomeComponent(props) {
        const { data, isLoading, errorMessage } = useData('someUrl')       // fetch hook rerenders the component on every loading state change
    }
    
    
// fetchHook.js ------------------------------------------------------------------
    import { useState } from 'react';
    
    export default function useFetchData(url) {
      const [data, setData] = useState();                                 // these states become the compoent's state for the component that uses this hook (this is how the original component rerenders on these state change)
      const [isLoading, setIsLoading] = useState(true);
      const [errorMessage, setErrorMessage] = useState('');
      
      useEffect(() => {
        try {
            setIsLoading(true);
            setErrorMessage('');
            setSensorData(undefined);
            const result = await fetch(url);
            setData(result);
        } catch (err) {
            setErrorMessage(err);
        } finally {
            setIsLoading(false);
        }
      }, []);
      
      return { data, isLoading, errorMessage };
    }
    </pre>
  </details>
  <!----------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> The <mark>useState()</mark> / <mark>useReducer()</mark> hooks</h2>
  <p> - <mark>useState()</mark> creates an individual state (multiple state can be used in a component) </p>
  <p> - <mark>useReducer()</mark> creates an individual state, changes its predefined state based on a dispatched action (different use of state) </p>
  <pre class="syntax">
    import React from 'react'
    
<span style="color:darkgray;">// <mark>useState()</mark> -------------------------------------------------------------------------</span>
    function <strong>Component</strong> () {
        const [<strong>stateVar</strong>, <strong>stateUpdateFn</strong>] = React.useState(<optval class="openable">val|fn<div>
        <p> - <reqval>val</reqval> - default state value </p>
        <p> - <reqval>fn</reqval> - called only once when the component mounts for the first time (and never again), the returned value will be the default state </p>
        </div></optval>) 
        
        <strong>stateVar</strong>                                                                       // value of the current state 
        <strong>stateUpdateFn</strong>(<strong class="openable">exp|fn<div>
            <p> - <reqval>exp</reqval> - expression result will be the new state </p>
            <p> - <reqval>fn(previousState)</reqval> - the returned value will be the new state </p>
        </div></strong>)                                                         // updates the state of its hook (the <strong>exp|fn</strong> result will be the new value of the hook state) (rerenders the component = changes the state)
    }                                                                                     
    
    
<span style="color:darkgray;">// <mark>useReducer()</mark> -----------------------------------------------------------------------</span>
    function <strong>reducerFn</strong>(<strong>state, action</strong>) {                                                // reducer function returns a state, (<strong>stateVar</strong> = previous state / <strong>action</strong> passed by <strong>dispatchFn</strong>)   
        <span style="color:darkgray;">// return the new state based on the received <strong>action</strong></span>    
    }
    
    function <strong>Component</strong> () {
        const [<strong>stateVar</strong>, <strong>dispatchFn</strong>] = React.useReducer(<strong>reducerFn</strong>, <optval class="openable">val|fn<div>
        <p> - <reqval>val</reqval> - default state value </p>
        <p> - <reqval>fn</reqval> - called only once when the component mounts for the first time (and never again), the returned value will be the default state </p>
        </div></optval>)
        
        <strong>stateVar</strong>                                                                       // value of the current state 
        <strong>dispatchFn</strong>(<strong>action</strong>)                                                             // dispatches the <strong>action</strong> to the <strong>reducerFn</strong> (dispatch specified <strong>action:str</strong> to change the state to the predefined value)
    }                                                                                     
    </pre>
  <details class="example">
    <summary> Example : </summary>
    <pre>
    import React, { useState } from 'react';
    
    function visibilityControl(visible) {
        if (visible === 'visible') return 'hidden';
        if (visible === 'hidden') return 'visible';
    }
    
    function TestComponent () {
        const [count, updateCount] = useState(0)                                       // multiple states can be used 
        const [visible, updateVisible] = useState(() => 'visible')                     // function will return the state value only once when the component mounts for the fist time (never called again)
        
        return (
            &lt;div&gt;
                &lt;p style={{visibility:visible}}&gt; {count} &lt;/p&gt;
                &lt;button onClick={ () =&gt; updateCount(count + 1) }&gt; add &lt;/button&gt;        // the result code inside <mark>updateCount</mark> will be the new state 
                &lt;button onClick={ () =&gt; updateVisible(visibilityControl) }&gt; hide / show &lt;/button&gt;      // we can also pass a function in <mark>updateVisible</mark>
            &lt;/div&gt;
        )
    }
    
    export default TestComponent    
    </pre>
    <pre>
    import React, { useReducer } from 'react';
    
    function reducer(state, action) {                                                  // reducer returns a predefined state based on the passed action 
        switch (action) {
            case 'reset':
                return 0;
            case 'increment':
                return state + 1;
            case 'decrement':
                return state - 1;
            default:
                return state
        }
    }
    
    function TestComponent () {
        const [count, dispatchCount] = useReducer(reducer, 0)

        return (
            &lt;div&gt;
                &lt;p&gt; {count} &lt;/p&gt;
                &lt;button onClick={ () =&gt; dispatchCount('increment') }&gt; add &lt;/button&gt;    // dispatching action 
                &lt;button onClick={ () =&gt; dispatchCount('decrement') }&gt; remove &lt;/button&gt;
                &lt;button onClick={ () =&gt; dispatchCount('reset') }&gt; reset &lt;/button&gt;
            &lt;/div&gt;
        )
    }
    
    export default TestComponent
    </pre>
  </details>
  <!----------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> The <mark>useEffect()</mark> / <mark>useLayoutEffect()</mark> hooks</h2>
  <p> - these hooks replace the old class component render function steps -> <mark>componentDidMount()</mark> -> <mark>componentDidUpdate()</mark> -> <mark>componentWillUnmount()</mark> </p>
  <p> - <mark>useEffect()</mark> - runs its function when the component is fully rendered </p>
  <p> - <mark>useLayoutEffect()</mark> - runs its function during component render (before React paints the DOM) <u>(can affect performance, never use it to update the component state)</u> </p>
  <pre class="syntax">
    import React from 'react'
    
    function <strong>Component</strong> () {
        React.useEffect(<strong class="openable">fn<div>
            <p> - we can return a 'cleanup' function what React calls when the component unmounts </p>
        </div></strong>, <opt class="openable">[<optval>val, ...</optval>]<div>
            <p> - only runs its function when any <optval>val</optval> changes <u>(always runs for the 1st time)</u> </p>
            <p> - <mark>[]</mark> (empty Array) -> runs its function only when the component mounts for the 1st time </p>
        </div></opt>)
        
        React.useLayoutEffect(<reqval class="openable">fn<div>
            <p> - we can return a 'cleanup' function what React calls when the component unmounts </p>
        </div></reqval>, <opt class="openable">[<optval>val, ...</optval>]<div>
            <p> - only runs its function when any <optval>val</optval> changes <u>(always runs for the 1st time)</u> </p>
            <p> - <mark>[]</mark> (empty Array) -> runs its function only when the component mounts for the 1st time </p>
        </div></opt>)                                 // does the same as <mark>useEffect()</mark> just the timing changes 
    } 
    
    
<span style="color:darkgray;">// <mark>useEffect()</mark> VS <mark>useLayoutEffect()</mark>----------------------------------------------------</span>

    <mark>useEffect</mark>                  <em>|| React business logic   ->   React paints the new DOM   ->   <mark>useEffect</mark></em>
    <mark>useLayoutEffect</mark>            <em>|| React business logic   ->   <mark>useLayoutEffect</mark>            ->   React paints the new DOM</em>
    </pre>
  <details class="example">
    <summary> Example : </summary>
    <pre>
    import React, { useState, useEffect, useLayoutEffect } from 'react';
    
    
    function TestComponent () {
        const [count, updateCount] = useState(0)
        
        useEffect(() => {
            console.log('component mouted')
            return () => console.log('component unmouted')
        }, [count]);                                                                   // runs its function only when the <mark>count</mark> stat changes (and for the first time)
        
        useEffect(() => {                                                              // runs every time the component is mounted / unmounted  
            console.log('component mouted')
            return () => console.log('component unmouted')
        });
        
        useEffect(() => {                                                              // runs only once when the component is mounted for the first time (empty Array passed <mark>[]</mark>)
            console.log('component mouted')
            return () => console.log('component unmouted')                             // cleanup function runs only when the component is unmounted 
        }, []);
        
        useLayoutEffect(() => {                                                        // essentially does the same as <mark>useEffect</mark> but runs its function right before React paints the new DOM  
            document.title = 'new title'
        }, [count]);
        
        return (
            &lt;div&gt;
                &lt;p&gt; { count } &lt;/p&gt;
                &lt;button onClick={() =&gt; updateCount(count + 1)}&gt; add &lt;/button&gt;
            &lt;/div&gt;
        )
    }
    
    export default TestComponent    </pre>
  </details>
  <!----------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> The <mark>useMemo()</mark> / <mark>useCallback()</mark> hooks</h2>
  <p> - these hooks are used to optimize performance </p>
  <p> - <mark>useMemo</mark> - returns a value computed by its function (the ide is to recompute the value only when needed) </p>
  <p> - <mark>useCallback</mark> - returns a callback (the idea is that the callback is recomputed only when needed (ex: used when the callback has some variables in it) </p>
  <pre class="syntax">
    import React from 'react'
    
    function <strong>Component</strong> () {
        const <strong>memoVar</strong> = React.useMemo(<strong>fn</strong>, <opt class="openable">[<optval>val, ...</optval>]<div>
            <p> - only runs its function when any <optval>val</optval> changes <u>(always runs for the 1st time)</u> </p>
            <p> - <mark>[]</mark> (empty Array) -> runs its function only when the component mounts for the 1st time </p>
        </div></opt>) 
        
        const <strong>fn</strong> = React.useCallback(<strong>fn</strong>, <opt class="openable">[<optval>val, ...</optval>]<div>
            <p> - only runs its function when any <optval>val</optval> changes <u>(always runs for the 1st time)</u> </p>
            <p> - <mark>[]</mark> (empty Array) -> runs its function only when the component mounts for the 1st time </p>
        </div></opt>)  
    } 
    </pre>
  <details class="example">
    <summary> Example : </summary>
    <pre>
    import React, { useMemo, useCallback } from 'react';
    
    function TestComponent () {
        const random = Math.random();
        
        const randomMemoized = useMemo(() => random, [])              // random given for the first time will be memoized
        
        const memoizedCallback = useCallback(() => random, [])        // the returned callback always returns the random given for the first time
    }
    </pre>
  </details>
  <!----------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> The <mark>useRef()</mark> hook</h2>
  <p> 1) - creates and returns an object that can be used as internal store (updating it <u>will not rerender the component</u> = state that not rerender the component when mutated) </p>
  <p> 2) - references a DOM object </p>
  <pre class="syntax">
    import { useRef, useEffect } from 'react';
    
<span style="color: darkgray;">// store data in ref object --------------------------------------------------- </span>
    function <strong>Component</strong>() {
        const <reqval>refVal</reqval> = useRef(<optval>val</optval>);  // creates and returns a <mark>{ current: <optval>val</optval> }</mark> object
        
        <reqval>refVal</reqval>;                      // -> { current: <optval>val</optval> }     // object will keep the data between rerenders
        <reqval>refVal</reqval>.current = <reqval>val</reqval>         // mutating the ref object will not rerender the component
    }
    
    
<span style="color: darkgray;">// referencing DOM element ---------------------------------------------------- </span>
    function <strong>Component</strong>() {
        const <reqval>refVal</reqval> = useRef(null);
        
        useEffect(() => {
            <reqval>refVal</reqval>.current            // references the DOM object (paragraph)
        }, []);
        
        return &lt;p ref={<reqval>refVal</reqval>}&gt; &lt;/p&gt;
    }
  </pre>
  <details class="example">
    <summary> Example : </summary>
    <h3 class="header"> using <mark>useRef</mark> to store values between rerenders </h3>
    <pre>
    import { useRef, useEffect } from 'react';
    
    function TestComponent() {
      const refVal = useRef('init val');      // keep set values between rerenders
    
      useEffect(() => {
        refVal.current = 'new val';           // mutating ref object will not tirgger the component rerender
        refVal.customProp = 'custom val';
      }, [])
    
      return (
        <p> some paragraph </p>
      )
    }
    
    export default TestComponent;
    </pre>
    <h3 class="header"> using <mark>useRef</mark> to reference a DOM element </h3>
    <pre>
    import { useRef, useEffect } from 'react';
    
    function TestComponent() {
      const refVal = useRef(null);
    
      useEffect(() => {
        console.log(refVal.current)       // -> paragraph DOM element
      }, [])
    
      return (
        &lt;p ref={refVal}&gt; some paragraph &lt;/p&gt;
      )
    }
    </pre>
  </details>
  <!--
    - useRef(<optval>val</optval>)
        - returns an object { current: <optval>val</optval> }
        - modifying this object will NOT rerender the component (this can be used well to store stuff in it!!!)
        - the returned object sotres values between rerenders (this makes them a perfect state that does not trigger rerender)
  
  
  - modifying several time the component state will not triggere that many rerenders (instead once the function executed all state are modified then one rerender will be triggered)
-->


  <br><br><br><br><br><br><br><br><br><br><br><br><br><br>

  <h2 class="headerExtra"> Referencing child components and calling function inside them <mark>useRef()</mark> / <mark>useImperativeHandle()</mark> / <mark>forwardRef()</mark> </h2>
  <p> - <mark>useRef()</mark> references a child component (or DOM element) </p>
  <p> - with <mark>useImperativeHandle()</mark> and <mark>forwardRef()</mark> we can call functions in the child component from the parent </p>
  <pre class="syntax">
    import React from 'react'
    import <strong>ChildComponent</strong> from './ChildComponent'
    
    function <strong>Component</strong>() {
        const <strong>chRef</strong> = React.useRef()                                                   // <strong>chRef</strong> will reference the child component    
        
        React.useEffect(() => {
            <strong>chRef</strong>.current.<strong>childFn</strong>()                                                    // calling the child component's function from the parent component (after the this component is fully rendered)    
        })
        
        return {
            &lt;<strong>ChildComponent</strong> ref={<strong>chRef</strong>}/&gt;
        }
    }
    
    
// <mark>ChildComponent.js</mark> ------------------------------------------------------------------
    import React from 'react'
    
    const <strong>ChildComponent</strong> = React.forwardRef((<strong>props, ref</strong>) => {                          // forward referencing the component    
        React.useImperativeHandle(<strong>ref</strong>, () => {
            <strong>fn</strong>() {}                                                                    // function that can be called from the parent component    
        })
    })
    
    export default <strong>ChildComponent</strong>
    </pre>
  <details class="example">
    <summary> Example : </summary>
    <pre>
    import React, { useRef, useLayoutEffect } from 'react';
    
    function TestComponent () {
        const el = useRef()
        
        useLayoutEffect(() => {
            el.current                                                                 // -> paragraph DOM element 
        })
        
        return (
            &lt;div&gt;
                &lt;p ref={el}&gt; test &lt;/p&gt;
            &lt;/div&gt;
        )
    }
    
    export default TestComponent
    </pre>
    <pre>
// Main.js ----------------------------------------------------------------------------
    import React, { useEffect, useRef } from 'react';
    
    import Child from './ChildComponent'
    
    function TestComponent () {
        const childRef = useRef()
        
        useEffect(() => {
            childRef.current.test();                                                   // calling functions is the child component  
            childRef.current.test2();
        })
        
        return &lt;Child ref={childRef}/&gt;                                                 // the component is wrapped in <mark>forwardRef</mark> so we can reference it 
    }
    
    export default TestComponent   
    
    
// Child.js ---------------------------------------------------------------------------
    import React, { forwardRef, useImperativeHandle } from 'react';
    
    const Child = forwardRef((props, ref) =&gt; {                                         // wrapping the component in <mark>forwardRef</mark>
      useImperativeHandle(ref, () =&gt; ({
          test() {console.log('test called!')},
          test2() {console.log('test2 called!')},
      }));
      
      return (
        &lt;div&gt;
          &lt;p Child Component &lt;/p&gt;
        &lt;/div&gt;
      )
    });
    
    export default Child; 
    </pre>
  </details>
  <!----------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="headerExtra"> Context <mark>createContext()</mark> / <mark>useContext()</mark> </h2>
  <p> - in React 18.0 we can create contexts, all components (no matter how deep) have access to the context state </p>
  <p> - in a context have a centralized state (object) which can be accessed and modified by any of the component in the context <u>(context state object properties are merged in the context state (like state works in class components))</u>
  <pre class="syntax">
// <mark>Main.js</mark> ----------------------------------------------------------------------------
    import React from 'react';
    import <strong>ChildComponent</strong> from './ChildComponent'
    
    cosnt <strong>__ctx</strong> = React.createContext(<strong>ctxObj</strong>)                                          // initializing context object (centralized state object)    
    
    function <strong>Component</strong>(){
        const <strong>ctx</strong> = React.useContext(<strong>__ctx</strong>)                                            // using the context inside the component    
        
        return (
            <em>&lt;Ctx.Provider value={<strong>ctx</strong>}&gt;</em>                                                 // all child components inside this context have access to <strong>ctx</strong>    
                &lt;<strong>ChildComponent </strong>/&gt;
            <em>&lt;/Ctx.Provider&gt;</em>
        )
    }
    
    export { <strong>__ctx</strong> }                                                                   // exporting context (cerntalized state)    
    
    
// <mark>ChildComponent.js</mark> ------------------------------------------------------------------
    import React from 'react'
    import { <strong>__ctx</strong> } from './Main'                                                     // importing context (cerntalized state)    
    
    export default <strong>ChildComponent</strong>(){
        const <strong>ctx</strong> = React.useContext(<strong>__ctx</strong>)                                            // <strong>ctx</strong> is the centralized state object (can be get or set)    
        
    }
    </pre>
  <details class="example">
    <summary> Example : </summary>
    <pre>
// Main.js ----------------------------------------------------------------------------
    import React, { createContext, useContext, useEffect } from 'react';
    
    import Child from './Child';
    import GrandChild from './GrandChild';
    
    const Ctx = createContext({p1:'child', p2:'grandChild'});                          // creates a context (with default value)
    
    function TestComponent () {
        const ctx = useContext(Ctx);                                                   // using context in the parent 
        
        useEffect(() => {
            console.log( ctx );                                                        // -> {p1: 'child', p2: 'grandChild', newProp: 'newVal'}     // cotext after components are fully rendered (the <mark>newProp</mark> is set by the GrandChild component)   
        });
        
        return (
            &lt;Ctx.Provider value={ctx}&gt;                                                 // context provider (all components inside have access to the context state)
            &lt;div&gt;
                &lt;p&gt; test &lt;/p&gt; 
                &lt;Child /&gt;
                &lt;GrandChild /&gt;
            &lt;/div&gt;
            &lt;/Ctx.Provider&gt;
        );
    };
    
    export { Ctx };                                                                    // exporting context 
    export default TestComponent;    
    
    
// Child.js ---------------------------------------------------------------------------
    import React, { useContext } from 'react';
    
    import { Ctx } from './Main';                                                      // importing context state 
    
    const Child = () => {
      const ctx = useContext(Ctx);                                                     // get context 
      
      return &lt;p&gt; Child Component value = {ctx.p1} &lt;/p&gt;
    };
    
    export default Child; 
    
    
// GrandChild.js ----------------------------------------------------------------------
    import React, { useContext } from 'react';
    
    import { Ctx } from './Main';                                                      // importing context state 
    
    
    const GrandChild = () => {
      const ctx = useContext(Ctx);                                                     // get context 
      
      ctx.newProp = 'newVal';                                                          // context state can be modified by any of the component members (porperties will be merged into the state context)
      cxt = null;                                                                      // -! the conext state inself cannot be changed (this thros an Error)
      
      return &lt;p&gt; Grand Child Component value = {ctx.p2} &lt;/p&gt;
    }
    
    export default GrandChild;    
    </pre>
  </details>


  <br><br>
</body>

</html>