<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title> NGINX </title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="../Assets/stylesPages.css">
  <script src="../Assets/scriptPages.js"></script>
</head>

<body>
  <h1> NGINX </h1>
  <p> Updated: 2023-07-15 </p>
  <p class="sitenav"> <a href="../index.html">MySite></a> NGINX
  <table class="table">
    <caption>
      commands
      <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
    </caption>
    <tr>
      <th style="width:30%;"> Command </th>
      <th> Description </th>
    </tr>
    <tr class="05.01">
      <td>
        nginx <small>[options]</small>
      </td>
      <td>
        - launches the NGINX daemon <br>
        <small>[options]</small><br>
        - (<small>-c <i>absoluteFilePath</i></small>) launches with config file <i>absoluteFilePath</i> <br>
        - (<small>-v</small>) prints the version <br>
        - (<small>-t</small>) checks the syntax validity of the <u>default config file</u> and prints its location <br>
        - (<small>-s reload</small>) reloads the currently used configs without interupting nginx <br>
        <p class="indent-lv1 no-margin">- if reloading fails (like config has syntax error) nginx will keep running with the old configs <u>BUT DOES NOT PRINT ANY ERRORS</u></p>
        - (<small>-s quit</small>) gracefull stop (wait for all worker processes to finish their current request) <br>
        - (<small>-s stop</small>) immediatley kills all nginx processes 
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      directives
      <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
    </caption>
    <tr>
      <th style="width:25%;"> Directive </th>
      <th style="width:15%;"> Available in Context </th>
      <th> Description </th>
    </tr>
    <tr class="01.01">
      <td>
        <a href="http://nginx.org/en/docs/dirindex.html" target="_blank">All directives</a>
      </td>
      <td>
        
      </td>
      <td>
        - all directives
      </td>
    </tr>
    <tr class="05.01">
      <td>
        listen <i>host:</i><strong>port</strong>|<strong>domainSocketPath</strong>;
      </td>
      <td>
        server
      </td>
      <td>
        - sets the host:port or domain socket on which the server listens (creates the domain socket if doesn't exist) <a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#listen" target="_blank">[link]</a> <br>
        - Default: <mark>*:80 | *:8000</mark>
      </td>
    </tr>
    <tr class="05.02">
      <td>
        server_name <strong>hostName:str|regEx|wildcard</strong> <i>...</i>;
      </td>
      <td>
        server
      </td>
      <td>
        - this virtual server will respond to requests having the <mark>Host</mark> header with this value
      </td>
    </tr>
    <tr class="07.01">
      <td>
        root <strong>dirPath</strong>;
      </td>
      <td>
        http / server / location / if in location
      </td>
      <td>
        - sets the root directory <br>
        - the requested path will be resolved on the host as <mark><strong>dirPath</strong> + <strong>requestPath</strong></mark>
      </td>
    </tr>
    <tr class="07.02">
      <td>
        alias <strong>dirPath</strong>;
      </td>
      <td>
        location
      </td>
      <td>
        - in the current <mark>location</mark> context <span class="openable">replaces the <mark>location</mark> context's path with <strong>dirPath</strong><div>
        <pre>
http {
    server {
        listen 3000;
        
        location /site {      # request <mark>localhost:3000/site/index.html</mark> resolved on the host as <mark>/var/www/site/index.html</mark>   
            alias /var/www;   # <mark>/site</mark> replaced by <mark>/var/www</mark>
        }
    }
}
        </pre></div></span> to resolve the resource on the host <br>
        - overrides the <mark>root</mark> directive
      </td>
    </tr>
    <tr class="10.01">
      <td>
        index <strong>file</strong> <i>...</i>;
      </td>
      <td>
        http / server / location
      </td>
      <td>
        - specifies the file lookup (on direcotry request) (Default: <mark>index index.html</mark>)
      </td>
    </tr>
    <tr class="10.01">
      <td>
        try_files
      </td>
      <td>

      </td>
      <td>
        -
      </td>
    </tr>
    
    
    
    
    
    
    
    
    <tr class="00.00">
      <td>

      </td>
      <td>

      </td>
      <td>
        -
      </td>
    </tr>


  </table>
  <br>
  <details class="example" id="notes">
    <summary> Notes & Tips :</summary>
    <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
  </details>
  <h2 style="color:green;"><u> Useful Links : </u></h2>
  <p><a href="https://gist.github.com/carlessanagustin/9509d0d31414804da03b" target="_blank">NGINX cheatsheet (GitHub) </a></p>
  <p><a href="http://nginx.org/en/docs/varindex.html" target="_blank">NGINX Alphabeticaly index of variables (nginx.org)</a></p>
  <p><a href="http://nginx.org/en/docs/dirindex.html" target="_blank">NGINX all eirectives (nginx.org)</a></p>
  <h2 style="color:green;"><u> Remember This : </u></h2>
    <p> - nginx doesn't show the currently used config file (what a carap), to see which config file is used run the <mark>ps aux | grep nginx</mark> command </p>
  <h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - NGINX is an open software originally deisgned for high performance web serving (to solve the famous <mark class="mark">C10K</mark> 10000 concurrent request problem), however there is also a paid version with enhanced capabilities <mark class="mark">NGINX Plus</mark></p>
    <p> - but NGINX is also: <mark class="mark">static web server or mail server</mark>, <mark class="mark">redirect & rewrite URLs</mark>, 
<mark class="mark">reverse proxy</mark>, <mark class="mark">load balancer</mark>, <mark class="mark">SSL termination point</mark>, <mark class="mark">distiribute traffic to specific services</mark>, <mark class="mark">handles caching</mark>, <mark class="mark">offers security features (such as authentication, DDOS protection, rate limiting, WAF, blacklisting etc...)</mark> </p>
    <p> - NGINX runs as daemon/service but can be controled from the foreground with the <mark>nginx</mark> command, essentially reads a config file (default: <mark>/etc/nginx/nginx.conf</mark>) </p>
    <p> - NGINX has a master process and serveral worker processes that follow the asynchronous event driven architecture </p>
    <p> - the master process evaluates the configuration and maintains the worker processes, worker processes are responsible to serve the actual request </p>
    <p> - NGINX Concepts: </p>
    <p class="indent-lv1"> - <mark class="mark">context</mark> : essentially a config scope (scope works just like in programmig languages (child scope inherit directives from higher levels but can be overriden in the current scope)) </p>
    <p class="indent-lv1"> - <mark class="mark">directive</mark> : key/value pair (can have multiple values) describing config instructions in the curren context </p>
    <p class="indent-lv1"> - <mark class="mark">zone</mark> : shared memory space </p>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> Simplest possible server </h4>
    <pre>
    http {
        server {
            listen 3000;
            
            return 200 "Hello World!";
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> Routing traffic based on request path </h4>
    <pre>
    http {
        server {
            listen 3000;
            root /var/www;
            
            location / {                      # main route
                index main.html;
            }
            
            location ~ \.(jpe?g|bmp|gif)$ {   # serves files from /var/www/images (when path ends with regex)
                root /var/www/images;
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> White listing </h4>
    <pre>
    http {
        geo $client_allowed {
            default       0;
            127.0.0.1     1;
        }
        
        server {
            listen 3000;
            
            if ($client_allowed = 0) {            # client address check
                return 403 "You're not allowed!";
            }
            
            location / {
                return 200 "Hello World!";
            }
        }
    }
    
    events {}
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
    <h2 class="header"> NGINX Contexts </h2>
    <pre class="syntax">
                                          // (top level) used to define core configs (like logs, etc...)
    http {                                // nests all http related configs and virtual servers
        server {                          // virtual server (or vhost) is basically a server namespace containing configs and routes 
            location <strong class="openable"><i>modifier</i> path<div>
                <p> - location with the highest precedence will be matched <u>no matter the declaration order</u></p>
                <p> - declaration order matters on same precedence </p> 
                <p> --- precedence 1 --- </p>
                <p> <mark>= <strong>path:str</strong></mark> -> exact route </p>
                <p> --- precedence 2 --- </p>
                <p> <mark>^~ <strong>path:str</strong></mark> -> preferential match (any path prefixed with <strong>path</strong>)</p>
                <p> --- precedence 3 --- </p>
                <p> <mark>~ <strong>path:regEx</strong></mark> -> case-sensitive regular expression</p>
                <p> <mark>~* <strong>path:regEx</strong></mark> -> case-insensitive regular expression</p>
                <p> --- precedence 4 --- </p>
                <p> <mark><strong>path:str</strong></mark> -> any path prefixed with <strong>path</strong> </p>
            </div></strong> { }   // contains configs for a specified location (url path)    
            location @<strong>namedLocation</strong> { }   // (named location) don't match any request paths, they are used in directives to redirect the traffic (like: <mark>error_page</mark>, <mark>try_files</mark>)
            <i>...</i>
        }
        <i>...</i>
    }
    
    events { }                            // contains global options for connection processing
    </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>loation</mark> context </h4>
    <pre>
    http {
        server {
            listen 3000;
            
            location /login {                     // different configs for different routes 
                return 200 "Login response";
            }
            
            location /content {
                return 200 "Content response";
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>loation</mark> context route matching precedence </h4>
    <pre>
    http {
        server {
            listen 3000;
            
            location ~ /login {                   # route precedence because both locations have the same precedence level (so declaration order matters here)  
                return 200 "Login response";
            }
            
            location ~ /login {
                return 200 "Content response";
            }
        }
    }
    
    events {}
    </pre>
    <pre>
    http {
        server {
            listen 3000;
            
            location ~ /test {
                return 200 "Regex match";           # matches 3rd (precedence 3)
            }
            
            location ^~ /test {
                return 200 "Preferential match";    # matches 2nd (precedence 2)
            }
            
            location = /test {                      # this will take effect (because it has the highest precedence) (precedence 1)
                return 200 "Exact match";
            }
        }
    }
    
    events {}
    </pre>
    <pre>
    http {
        server {
            listen 3000;
            
            location ^~ /images/ {
                // config for path prefixed with <mark>/images/</mark>
            }
            
            location ~* \.(gif|jpg|jpeg)$ {
                // config for path that ends with matching regex <mark>\.(gif|jpg|jpeg)$</mark> (when the path doesn't start with <mark>/images/</mark>)    
            }
            
            location / {
                // fallback path configs
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>location</mark> used as named location </h4>
    <pre>
    http {
        upstream backup_server {
            server localhost:3004;
        }
        
        server {
            listen 3000;
            
            location / {
                try_files invalid/route @fallback;      # redirects the traffic to fallback location if file not found
            }
            
            location @fallback {
                return 200 "Fallback Content";
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>events</mark> context </h4>
    <pre>
    http {
        server {
            listen 3000;
            
            location / {
                return 200 "Hello World!";
            }
        }
    }
    
    events {
        worker_connections 1024;      # maximum number of simultaneous connections
    }
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> Context execution & Inheritance </h2>
    <p> - a context executes from top to bottom, the <mark>return</mark> statement can break further execution </p>
    <p> - nested directives override directives that are inherited from the parent context (just like scoping works in programming languages) </p>
    <pre class="syntax">
    <strong>ctx</strong> {
        set $<strong>someVar</strong> <strong>valA</strong>;
        
        <strong>ctx</strong> {
            set $<strong>someVar</strong> <strong>valB</strong>;            // override parent variable (in the local scope)
            
            return <strong>httpCode str</strong>;          // breaks further exectution 
        }
    }
    </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <pre>
    http {
        gzip on;
        
        server {
            gzip off;       # overrides this directive in this context
            
            listen 3000;
            
            location / {
                gzip off;     # overrides this directive in this context (again)
                
                root "/home/arpad/projects/My-Knowledge-Base/My Site";
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> the <mark>return</mark> statement breaks further context execution </h4>
    <pre>
    http {
        geo $client_allowed {
            default       0;
            127.0.0.1     1;
        }
        
        server {
            listen 3000;
            
            if ($client_allowed = 0) {            # client address check
                return 403 "You're not allowed!";
            }
            
            location / {
                return 200 "Hello World!";
            }
        }
    }
    
    events {}
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> Importing configurations </h2>
    <pre class="syntax">
    import <strong>absoluteFilePath</strong>;              // imports the file and pareses the content as nginx config (can be used in any context)
    </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <pre>
    http {
        server {
            include "/home/arpad/projects/My-Knowledge-Base/My Site/NGINX/server.conf";
        }
    }
    
    events { }
    
    
// server.conf ------------------------------------
    root "/var/www/test";
    index test.index;
    listen 3000;
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> Mime type to file extension mapping </h2>
    <p> - when serving files NGINX must map file types to mime types, the <mark>types</mark> context does this (NGINX comes with default mime type mapping, located in <mark>/etc/nginx/mime.types</mark>) </p>
    <pre class="syntax">
    types {
        <strong>mimeType</strong> <strong>fileExtension</strong> <i>...</i>;       // maps <strong>mimeType</strong> to file extenstion(s) (default: <mark>text/plain</mark> -> for non specified file extensions)    
        <i>...</i>
    }
    </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <pre>
    http {
        types {                         # file extension to mime types mapping 
            text/html               html;
            text/css                css;
            application/javascrpt   js;
        }
    
        server {
            listen 3000;
            root "/var/www";
            
            location / {
                index test;
            }
        }
    }
    
    events {}
    </pre>
    <pre>
    http {
        include /etc/nginx/mime.types;    # default nginx mime type mapping
    
        server {
            listen 3000;
            root "/var/www";
            
            location / {
                index test;
            }
        }
    }
    
    events {}
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> Variables / <mark>if</mark> statement / <mark>map</mark> statement / <mark>geo</mark> statement </h2>
  <pre class="syntax">
<span style="color: darkgray;">// variables (allowed in context <mark class="mark">http</mark> / <mark class="mark">server</mark> / <mark class="mark">location</mark> / <mark class="mark">if</mark>) --------------------------------------</span>
    set $<strong>var</strong> <strong>val</strong>;                         // declares a new varialbe (variable scoping works as in programming languages) (<mark class="mark">location</mark> only)
    $<strong>var</strong>                                  // using variable <u><a href="http://nginx.org/en/docs/varindex.html" target="_blank">(there are a ton of built-in varialbes)</a></u>
    
    
<span style="color: darkgray;">// <mark>if</mark> statement (allowed in context <mark class="mark">http</mark> / <mark class="mark">server</mark> / <mark class="mark">location</mark>) ----------------------------------------</span>
    if (<strong>cond</strong>) {                           // executes the code block if <strong>cond</strong> evaluates true
        <i>some code ...</i>
    }
    
    
<span style="color: darkgray;">// <mark>map</mark> statement (allowed in context <mark class="mark">http</mark>) -----------------------------------------------------------</span>
    map <strong>str|varA</strong> <strong>varB</strong> {                   // basically a case statement 
        default <strong>val</strong>;                      // default case 
        <strong class="openable">case:str|regEx<div>
          <p> - <mark><strong>str</strong></mark> - exact match </p>
          <p> - <mark>~<strong>str</strong></mark> - regEx case-sensitive match </p> 
          <p> - <mark>~*<strong>str</strong></mark> - regEx case-insensitive match </p> 
        </div></strong> <strong>val</strong>;              // if <strong>str|varA</strong> == <strong>case</strong> assigns <strong>val</strong> to <strong>varB</strong> (otherwise tries the next case)   
        <i>...</i>
    }
    
    
<span style="color: darkgray;">// <mark>geo</mark> statement (allowed in context <mark class="mark">http</mark> / <mark class="mark">server</mark> / <mark class="mark">location</mark>) ---------------------------------------</span>
    geo <strong>var</strong> {                             // case statement which check the <mark>$remote_addr</mark> (remote address built-in variable) against casses (used to assign some value to a variable based on the remote address)   
        default <strong>val</strong>;                      // default case 
        <strong>case</strong> <strong>val</strong>;                         // if <mark>$remote_addr</mark> == <strong>case</strong> assigns <strong>val</strong> to <strong>var</strong> (otherwise tries the next case)   
        <i>...</i>
    }
  </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> Variables </h4>
    <pre>
    http {
        server {
            set $hw "Hello World!";
            listen 3000;
            
            location = / {
                return 200 $hw;
            }
            
            location /somePath {
                set $hw "Hello World overriden!";   # local variable
                return 200 $hw;
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>if</mark> statement </h4>
    <pre>
    http {
        server {
            listen 3000;
        
            location / {
                if ($request_method != "GET") {       # block executed when the request method is not GET
                    return 405 "Only 'GET' request method allowed";
                }
                return 200 "OK";
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>map</mark> statement </h4>
    <pre>
    http {
        map $uri $return_value {      # basically a JavaScript case-like statement the <mark>$uri</mark> (built-in variable) is mapped to <mark>$return_value</mark> based on the case
            /test "Test";
            / "Root";
            default "Default";
        }
        
        server {
            listen 3000;
            
            location / {
                return 200 $return_value;
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>geo</mark> statement </h4>
    <pre>
    http {
        geo $locahost {       # checks if any case matches the <mark>$remote_addr</mark> built-in variable (remote address)   
            127.0.0.1   1;
            ::1         1;
            default     0;
        }
    
        server {
            listen 3000;
            location / {
                if ($locahost = 0) {
                    return 403 "Only localhost request allowed!";
                }
                return 200 "OK";
            }
        }
    }
    
    events {}
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="headerExtra"> Directives </h2>
  <h3 class="header"> The <mark>listen</mark> / <mark>server_name</mark> directives </h3>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>listen</mark> directive </h4>
    <pre>
    http {
        server {
            listen 172.17.0.2:3000; 
            
            location / {
                return 200 "Hello World!";
            }
        }
    }
    
    events { }
    </pre>
    <pre>
    http {
        server {
            listen unix:/var/run/nginx.sock;        # listening on domain socket  
            
            location = /test {
                return 200 "Hello World!";
            }
        }
    }
    
    events { }
    </pre>
    <h4 class="header"> <mark>server_name</mark> directive </h4>
    <pre>
    http {
        server {
            listen 3000;
            server_name test1 test2;        # server responds to requests having the <mark>Host: test1|test2</mark> header (or any rquests -> this is the default)
            
            location / {
                return 200 'respond to test1 or test2';
            }
        }
        
        server {
            listen 3000;
            server_name test3 test4;        # server responds to requests having the <mark>Host: test3|test4</mark> header
            
            location / {
                return 200 'respond to test3 or test4';
            }
        }
        
        server {
            listen 3000;
            server_name MiciMacko.com;       # server responds to requests having the <mark>Host: MiciMacko.com</mark> header
            
            location / {
                return 200 'Mici Macko responded brum brum!';
            }
        }
    }
    
    events {}
    </pre>
  </details>
  <h3 class="header"> The <mark>root</mark> / <mark>alias</mark> directives </h3>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>root</mark> directive </h4>
    <pre>
    http {
        root /var/www/test_site;    # the requested path will be resolved on the host as <mark>/var/www/test_site<strong>requestPath</strong></mark>   
        
        server {
            listen 3000;
        }
    }
    
    events { }
    </pre>
    <h4 class="header"> <mark>alias</mark> directive </h4>
    <pre>
    http {
        server {
            listen 3000;
            root /log;
            
            location /images {                                    # request <mark>localhost:3000/images/hi.jpg</mark> resolved on the host as <mark>/var/www/test_site/images/hi.jpg</mark>
                alias /var/www/test_site/images;                  # <mark>/images</mark> replaced by <mark>/var/www/test_site/images</mark> + remaining request path
            }
            
            location /tests {                                     # request <mark>localhost:3000/tests/render.test</mark> resolved on the host as <mark>/var/www/test_site/e2e/render.test</mark>
                alias /var/www/test_site/e2e;                     # <mark>/tests</mark> replaced by <mark>/var/www/test_site/e2e</mark> + remaining request path
            }
            
            location /data {                                      # request <mark>localhost:3000/data/me.txt</mark> resolved on the host as <mark>/var/www/test_site/ready_data/public/me.txt</mark>
                alias /var/www/test_site/ready_data/public;       # <mark>/data</mark> replaced by <mark>/var/test_site/ready_data/public</mark> + remainng request path
            }
        }
    }
    
    events { }
    </pre>
  </details>
  <h3 class="header"> The <mark>index</mark> / <mark>try_files</mark> / <mark>error_page</mark> directives </h3>
  <details class="example" open>
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>index</mark> directive </h4>
    <pre>
    http {
        index main.html index.html;       # default file lookups (on directory request)
        root /var/www/site;
        
        server {
            listen 3000;
        }
    }
    
    events { }
    </pre>
    <h4 class="header"> <mark>try_files</mark> directive </h4>
    <pre>
    
    
    
    
    </pre>
    
    
  </details>


<!--
    directives:
        index <strong>file</strong>               - (location, server) default file to serve (default: <mark>index.html</mark>)
        
        
        
        
        try_files <strong>filePath|uri</strong> <i>...</i> =<strong>httpCode</strong>    - (server, location) serves the first found file for the request
                                                            - if file is not found the previous valid file is served
                                                            - the path to the file is constructed relative to <mark>root</mark> or <mark>alias</mark> directive
                                                            - path 
                                                            - give an example for named location as well
    
    
    
    
        error_page <strong>httpCode</strong> <i>...</i> <small>=<i>httpCode</i></small> <strong>filePath|url</strong>
                                                  - (http, server, location, if in location) serves error page at <strong>filePath</strong> if <strong>httpCode</strong> is thrown (we also can redirect)
                                                  - optionally serves <i>httpCode</i> instead of <strong>httpCode</strong> <i>...</i> http codes

-->




  <!--
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
stage 1: high level overview 
    - read through 
    - create notes 
    - deciede what exactly will you document down 
    
stage 2:  low level overview
    - deeper understanding of all what you've taken down in stage 1
    
stage 3 : 
    - organize and document down everything
    
    
    
    
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
- main explanaition (if, var, etc... stuff)
    - include here virtal hosts (servers)
        - variables and shit
        - contexts
    
    
- rewrite & redirect 
    
- Proxy -> upstream (load balancing) 
    
- SSL termination 
    
- authentication 
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
    directives:
        index <strong>file</strong>               - (location, server) default file to serve (default: <mark>index.html</mark>)
        
        
        try_files <strong>filePath|uri</strong> <i>...</i> =<strong>httpCode</strong>    - (server, location) serves the first found file for the request
                                                            - if file is not found the previous valid file is served
                                                            - the path to the file is constructed relative to <mark>root</mark> or <mark>alias</mark> directive
                                                            - 
    
        error_page <strong>httpCode</strong> <i>...</i> <small>=<i>httpCode</i></small> <strong>filePath|url</strong>
                                                  - (http, server, location, if in location) serves error page at <strong>filePath</strong> if <strong>httpCode</strong> is thrown (we also can redirect)
                                                  - optionally serves <i>httpCode</i> instead of <strong>httpCode</strong> <i>...</i> http codes
    
    
        add_header <strong>headerName</strong> <strong>headerValue</strong> [always];     <- adds a header to the response (for 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 response codes only)
            - always -> for all response codes
        limit_except <strong>httpMethod</strong> <i>...</i> {     - (location) only the listed http methods allowed in the location
            <i>configs...</i>
            deny all;
        }
      
      
        worker_processes <strong>int</strong>;    - (main) how many worker processes to create (default: 1)
        worker_connections <strong>int</strong>;  - (events) maximum connection per wroker process (default: 512)
    
    
    
        - compression
        gzip on|off;                # enables|disables content encoding (includes Content-Encoding gzip in the response)
        gzip_types <strong>mimeType</strong> <i>...</i>         # by default only <mark>text/html</strong> mime typed files are compressed, here we can add files to the compression 
    
    
      
      
      access_log <strong>path</strong>;           <- sets the access log path 
      error_log <strong>path</strong>;            <- error log path
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        rewrite <strong>path:regEx</strong> <strong>path:str</strong>        # redirects <strong>path:regEx</strong> to <strong>path:str</strong> but URL stays at <strong>path:regEx</strong
        
        
    
    
        upstream {                                # defines a group of servers (for load balancing)
            least_conn;                           # load balancing (traffic routed to the server having the least active connection)
            ip_hash;                              # calculates a hash based on the client's IP in order to always route the client to the same backend server 
        
        
            server <strong>url|ip:port</strong> <i>options</i>;
            <i>...</i>
            
            server <strong>url|ip:port</strong> backup;       # backup server (when all goes down)
        }
        
        - options 
          - weight=<strong>int</strong>     (default 1) proportion relative to other server weights
        - if no weight specified the load is distributed in Round-Robin style
        - load balancing methods
            - Round Robin
            - Weighted Round Robin
            - ip hash
            - <a href="https://www.javatpoint.com/nginx-http-load-balancing" target="_blanc">more...</a> such as Generic Hash, 
          - max_fails=<strong>int</strong>      - after this many failed attempts nginx marks this server unavailable (and reroutes the trafic to another server)
          - fail_timeout=<strong>int</strong>s|m      - for this duration is marked the server as unavailable (after expiration nginx routes traffic to this server as well)
        
        
        - active health check is available for nginx plus only
        
        
        
        
        
        
        
        - SSL termination point
        
        
        
        listen <strong>port:int</strong> ssl;       # ssl connection will be estabilished
        
        ssl_certificate <strong>pathToCert</strong>         # path to cert and cert key files 
        ssl_certificate_key <strong>pathToCertKey</strong>
        
        ssl_protocols <strong>protocol</strong> <i>...</i>      - (http, server) - restricts the ssl connection protocol (Default: <mark>TLSv1 TLSv1.1 TLSv1.2 TLSv1.3</mark>)
        ssl_ciphers <strong>cipherList<strong>                  - allowed ciphers (Default: <mark>HIGH:!aNULL:!MD5</mark>) (to check included ciphers run <mark>openssl ciphers -V 'HIGH:!aNULL:!MD5'</strong>)
        
        
        
        
        
        - basic authentication (this worked only when webpage server)
            - for this we have to create a user password file with <mark>htpasswd -c <strong>pathtopasswdFile</strong> <strong>user</strong></mark>
            (run without -c to add more users)
            
        auth_basic <strong>msg</strong>           <- (http, server, location, limit_except
) this message will be prompted to the user
        auth_basic_user_file <strong>pathtopasswdFile</strong>      <- path to passwd file (http, server, location, limit_except
)
        
        
        
        - caching 
        https://www.javatpoint.com/nginx-content-caching
        
        
        
        
        ------------------- upstream_cache_status -------------------
        
        
        proxy_cache_path <strong>path</strong>        <- sets the cache path (http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path)
        
        proxy_cache <strong>zone</strong>|off;       <- (http, server, location) enables|disables caching
        
        proxy_cache_valid <strong>httpVerb</strong>|any <strong>time<strong>    <- (http, server, location) cache valide for specified request 
        
        proxy_cache_purge <strong>bool</strong>     <- (http, server, location) enables|disables caching (NGINX Plus only)
        
        
        
  --- directives ---
      ip_hash             <- (upstream) request will be sent to the same upstream server 
        
        
        
        
        
        default access and error log directives are in /var/log/nginx/access.log|error.log
        
      
        
        
        
        
        
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
?????????????????????????????????????????????????????????????????????????????????????????????
WRITE DOWN WHAT YOU DON'T UNDERSTAD OR MUST BE TESTED AS QUESTIONS HERE
?????????????????????????????????????????????????????????????????????????????????????????????
    nginx -s reopen     - reopen log files (close current log files and open new onces)         <- TEST THIS (does this guy log in the error log???)
    
    
    logging?
    caching?
    
    - delete cache
    
    
    
    
-------- DONE --------
    - can I use variables?
        - yep demoed 
        
    - how to set up config file location?
        - with the -c flag
    
    
    - nginx is a daemon 
        - well on Mac I run it not as daemon <- how the heck?
        - can I run it as not a daemon?
        - if used as daemon how to configure custom config/access.log/error.log files ???
    
            -> runs as a daemon/service but we can control it from the foreground 
-->























<!--




        root <strong>dirPath</strong>;            - (http, server, location) root directory for the REQUEST 
                                                  - nginx servers resources relative to /
                                                  - further resoures
        alias <strong>dirPath</strong>;           - (location) maps the current location to a specified directory 
                                                  - overrides root directory for the specified location 
                                                  
                                                  




        listen <strong>port</strong>;             - (server) server listens on this [host]:port or 
              <strong>address:port</strong>;
              unix:<strong>domainSocketPath</strong>;      - creates the domain socket
        
        https://nginx.org/en/docs/http/ngx_http_core_module.html#listen
        
        
        
        
        server_name <strong>hostName:str|reGex|wildcard</strong>;     # (server) specifies the hostname for the current virtual server
                                                                      # this guy also looks for the "Host" header and directs the trafic to this virtual server 
        
        
        
        - virtual hosting
          - with the server_name directive we can setup multiple backend virtual servers
        
        
        server {
            listen <strong>port:int</strong>;
            server_name <strong>hostName:wildCard|regEx</strong> <i>...</i>;       # a list of hosts to which this virtual server responds 
        
        }

        types {                                   - (http, server, location) mime type to file extention type mapping
            <mime.type> <fileExtension>           - ex: text/css   css
        
        }


        include <strong>filePath</strong>;        - includes the specified file (ex: include mime.type or other config file)


    contexts:
        http {}                                   - (main) global http server related configurations (nests all virtual servers <mark>server</mark> context)
        events {}                                 - (main) connection directives are located here
        
        server {}                                 - (http) describes a virtual server (nginx routes requests to specific virtual servers)
        server {
            return <strong>httpCode</strong> <strong>str</strong>     # serves <strong>str</strong> with <strong>httpCode</strong> <strong>str</strong>
        }
        
        
        
        location <i>modifier</i> <strong>uri</strong> {       - (server, location) provides configuratios for the location that matches <strong>uri</strong> (adds this location to all previously normalized URI path) 
                                                  
        }
        
        # modifiers (in precedence order)
        - = <strong>str</strong?            -> exact match 
        - ^~ <storng>/path:str</strong>     -> preferential match (useful when we want to match a location over regEx modifiers)
        - ~ <strong>path:regEx</strong>    -> case-sensitive regEx match
        - ~* <strong>path:regEx</strong>   -> case-insensitive regEx match 
        - <storng>/path:str</strong>        -> any request that prefixed with <mark>/path</strong>
        - 
        
        
        location <i>modifier</i> <strong>uri</strong> {       # (server, location) redirects to <stong>path:str</strong>
            return <strong>httpCode</strong> <stong>path:str</strong>|<strong>str</strong>
        }
        
        location @<strong>locationName</strong> {       # <strong>locationName</strong> can be used in <mark>try_files</mark>
            config....
        }




    - nginx provides the <mark>mime.types</mark> file on install which provieds a full (mime type map)  <- document this 


        http {}                                   - (main) global http server related configurations (nests all virtual servers <mark>server</mark> context)
        events {}                                 - (main) connection directives are located here
        
        server {}                                 - (http) describes a virtual server (nginx routes requests to specific virtual servers)
        server {
            return <strong>httpCode</strong> <strong>str</strong>     # serves <strong>str</strong> with <strong>httpCode</strong> <strong>str</strong>
        }
        
        
        
        location <i>modifier</i> <strong>uri</strong> {       - (server, location) provides configuratios for the location that matches <strong>uri</strong> (adds this location to all previously normalized URI path) 
                                                  
        }
        
        # modifiers (in precedence order)
        - = <strong>str</strong?            -> exact match 
        - ^~ <storng>/path:str</strong>     -> preferential match (useful when we want to match a location over regEx modifiers)
        - ~ <strong>path:regEx</strong>    -> case-sensitive regEx match
        - ~* <strong>path:regEx</strong>   -> case-insensitive regEx match 
        - <storng>/path:str</strong>        -> any request that prefixed with <mark>/path</strong>
        - 





        if (<strong>cond</strong>) {                        # (server, location) runs the block if <strong>cond</strong> is truthy (no recommended because the condition is evaluated on request therefore it can cost some performance)
            // code to run if condition is truthy...
        }
        
        
        - variables (give a few examples of built in variables) -> using variables are discuraged by nginx 
        - there are built-in variables 
        - not all variables can be used in all contexts 
        
        set $<strong>varName</strong> <strong>val</strong>      # declaring a variable
        $<strong>varName</strong>                               # using the declared variable 
        
        
        - variable mapper stuff
        map $<strong>inputVar</strogn> $<strong>outputVar</strogn> {
            default <strong>str</strong>;       # fallback value
            <strong class="openable">case<div>
                <p> - <storng>str</strong> - exact match </p>
                <p> - <mark>~<storng>str</strong></mark> - regEx case-sensitive match </p> 
                <p> - <mark>~*<storng>str</strong></mark> - regEx case-insensitive match </p> 
            </div></strong>
            <i>...</i>
        }
        
        geo $<strong>var</strong> {         # assigns value to $<strong>var</strong> based on address
            default <strong>str</strong>;   # fallback value
        
            <strong>addess</strong> <strong>val<strong>;
            <i>...</i>
        }



    - concepts:
    - in config file
      - directive -> key value pair
      - context -> between {}
          - the directive value is overriden in local context
      - zone -> shared memory space
    

    - nginx is an open software, however nginx plus is a comertial version having extra functionalities
    nginx solves the famous C10K problem (10000 concurent requests)
    
    
    NGINX is a reverse proxy;
      - SSL termination point (SSL offloading from backend servers)
      - static web server or mail server
      - load balancer
      - cache
      - offers securty features (rate limiting, DDOS protection, WAF, etc.)
      - rewrites and redirects URLs
      - can be used to distribute trafic between microservices
      - content compression (gzip, Brotli)
      - blacklisting 
      - in nginx plus we can pull in modules with extra functionalities
      
      
    - event driven asynchronous architecture that can handle 10000 concurrent connections
    - the whole thing is configurable through a nginx.conf file 


    cmd:
        nginx [-c <path_to_.conf>]                   - start nginx (optionaly with a custom config)
        nginx -s stop       - fast shutdown (immediately kills all workers)
        nginx -s quit       - graceful shutdown (wait for workers to finish their current requests)
        nginx -s reload     - reloads config file
        nginx -s reopen     - reopen log files (close current log files and open new onces)         <- TEST THIS
    
        nginx -t            - check for default config file syntax errors, also prints location (at the time of writing this there's now way for custom config file syntax check)
    
    
    - consist of a master proces and its workers
      - the master process reads and evaluates configuration, and maintain worker processes
      - worker processes are responsibles to serve the actual content
    




-->

  <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
  <hr>
  <hr>
  <hr>
  <hr>
  <hr>


  <h2 class="headerExtra"><u> Title 1 </u></h2>
  <h2 class="header"> Title 1.1 </h2>
  <h3 class="header"> Title 1.1.1 </h3>
  <h4 class="header"> Title 1.1.1.1 </h4>
  <p> - stuff to learn <mark>syntax or command (or some tchnical stuff)</mark> bla bla bla </p>
  <p> - stuff to learn <mark class="mark">highlights like file names and other things</mark> bla bla bla </p>
  <p style="text-decoration:underline;"> - important information is underlined </p>
  <p style="color:yellow;"> - very important information is written with yellow colors </p>
  <p style="background-color:yellow;"> - highly important information has yellow background color </p>
  <div style="background-color:red;">
    <p> - red background block means not learned or not tested information! </p>
    <p> - </p>
  </div>

  <pre class="syntax">
SYNTAX :    main syntax
            <em>literally used </em>
            <small>literally used optional </small>
            <prot style="color:#049500;">prototype chain</prot>
            <strong>required value </strong>
            <i>optional value </i>
                - some descriptions will come here (like arguments)
                - ??? (3 question marks) in syntax means not tested or not learned yet
                
            <span class="openable"> this is an openable element<div>
                <p> - openable elements listed here in paragraphs </p>
                <p> - </p>
            </div></span>
    </pre>

  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <pre>
    examples of the current lessons 
    
// -----------------------------------------

// -----------------------------------------
    </pre>
  </details>

  <pre class="cmd">
    command line demo 
    </pre>
  <pre class="formula">
    formula code (like conversion meter...)
    </pre>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> example title </u></h4>
    <p> - live tests will come here </p>
    <details>
      <summary> CODE : </summary>
      <pre>
    copy of the exaple code 
        </pre>
    </details>
  </details>
  <!---------------------------------------------------------------------------------------------------------------------------------->
  <hr>

  <h2 class="test" style=""><a href="TEST/index.html"> TEST > </a></h2>


  <br><br>
</body>

</html>