##########################################################################
# simplest possible server
##########################################################################


# http {
#     server {
#         listen 3000;
        
#         return 200 "Hello World!";
#     }
# }

# events {}



##########################################################################
# context inheritences
##########################################################################
# http {
#     gzip on;
    
#     server {
#         gzip off;       # overrides the parent value in local context
        
#         listen 3000;
        
#         location / {
#             gzip on;     # overrides the parent value in local context (again)
            
#             root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site";
#         }
#     }
# }

# events {}



##########################################################################
# specifying mime types
##########################################################################

# http {
#     types {                         # mime types mapping (to server the file as the mapped mime type)
#         text/html               html;
#         text/css                css;
#         application/javascrpt   js;
#     }

#     server {
#         listen 3000;                      # server listens on localhost:8080
#         # listen 192.168.0.206:3000;      # server listens on the host's address
#         root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site";      # the root directory for the request 
#     }
# }

# events {}



##########################################################################
# including external files <mark>include</mark>
##########################################################################
# http {
#     include /opt/homebrew/etc/nginx/mime.types;     # includes the file in this config (<mark>mime.types</mark> is the default mime type to file mapping provided by nginx)

#     server {
#         listen 3000;
#         root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST";
#     }
# }

# events {}


##########################################################################
# alias / index directives
##########################################################################
# index directive ---------------------------------------------------------
# http {
#     include /opt/homebrew/etc/nginx/mime.types;
    
#     server {
#         listen 3000;

        # location / {
        #     root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST";
        #     index test_1.txt;       # when requesting <mark>/<mark> this file will be serverd as default (index.html is the default)
        # }
        
        
# root VS alias directives ------------------------------------------------
        # when requesting <mark>/test</mark> essentially files are served from <mark>/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST/test</mark> because of the <mark>root</mark> directive 
        # location /test {
        #     root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST";
        # }
        
        # when hitting <mark>/test2</mark> essentially files are served from <mark>/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST</mark> because of the alias directive 
        # location /test2 {
        #     alias "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST";    # this basically gives root for the URI location  
        # }



##########################################################################
# location context
##########################################################################
# http {
#     include /opt/homebrew/etc/nginx/mime.types;
    
#     server {
#         listen 3000;
    
#         location /base {        # will match any URL that starts with <mark>/base</mark> (ex: <mark>/base/site1</mark>)
#             alias "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST";
#             index test_1;
#         }
        
#         location = /test_1 {     # will match only URL <mark>/test_1</mark>
#             root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST";
#         }
        
        
#         # regular expression matching
#         # this will match any request prefixed with <mark>/test</mark> 
#         location ^~ /test {
#             alias "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST1/test";
#         }
        
#         # this will match any request that starts with <mark>/t</mark> 
#         # this won't match any request prefixed with <mark>/test</mark> because the <mark>^~</mark> modifier has higher precedence
#         location ~ /t.* {
#             alias "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST2/test_1";
#         }
#     }
# }

# events {}


##########################################################################
# named location context
##########################################################################
# http {
#     upstream backup_server {
#         server localhost:3004;
#     }
    
#     server {
#         listen 3000;
#         root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX";
        
        
#         location / {
#             try_files $uri @backup;     # if the requested file is not found then the request is redirected to the upstream server
#         }
        
#         location @backup {
#             proxy_pass http://backup_server;
#         }
#     }
# }

# events {}


##########################################################################
# using if statement
##########################################################################
# http {
#     server {
#         listen 3000;
#         root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX";
    
#         location / {
#             if ($request_method != "GET") {       # block executed when the request method is not GET
#                 return 405 "Only 'GET' request method allowed";
#             }
#         }
#     }
# }

# events {}


##########################################################################
# error_page directive
##########################################################################
# http {
#     include /opt/homebrew/etc/nginx/mime.types;
    
#     server {
#         listen 3000;
    
#         location / {
#             root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX";
            
#             # error_page 404 =405 /error.html;            # if a 404 is thrown the error page <mark>/error.html</mark> is served with 405 error code
#             error_page 404 http://localhost:3003;     # redirecting to a URL
#         }
#     }
# }

# events {}



##########################################################################
# try_files directive
##########################################################################

# http {
#     include /opt/homebrew/etc/nginx/mime.types;
    
#     server {
#         listen 3000;
    
#         location / {
#             root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST";
#             try_files $uri /testX =405;
#         }
#     }
# }

# events {}


##########################################################################
# redirecting
##########################################################################
# http {
#     include /opt/homebrew/etc/nginx/mime.types;
    
#     server {
#         listen 3000;
        
#         location /base {
#             alias "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST";
#             index test;
#         }
        
#         location / {
#             return 301 /base;       # redirecting to <mark>/base</mark>
#         }
#     }
# }

# events {}



##########################################################################
# rewriting
# ##########################################################################
# http {
#     include /opt/homebrew/etc/nginx/mime.types;
    
#     server {
#         listen 3000;
        
#         rewrite /newPath /test;           # url stays at /newPath but redirected to /test
        
#         location /test {
#             alias "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST";
#             try_files /index.html /test =404;
#         }
        
#     # --------------------------------------
#         rewrite /\d.* /randomDigit;
        
#         location /randomDigit {
#             alias "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST";
#             try_files /digit =404;
#         }
        
#     # --------------------------------------
#         rewrite /(\d).* /getDigit/digit_$1;   # using captured regExp group value
        
#         location ~* /getDigit/digit_\d {
#             root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST";
#         }
#     }
# }

# events {}


##########################################################################
# simple load balancer
# ##########################################################################
# http {
#     upstream backend {              # group of servers 
#         server localhost:3001;            # load in distributed in Round Robin style
#         server localhost:3002;
#         server localhost:3003;
#         server localhost:3004 backup;     # server kicks in when ALL the balancer servers are down
#     }
    
#     server {
#         listen 3000;
        
#         location / {
#             proxy_pass http://backend;
#         }
#     }
# }

# events {}


##########################################################################
# weighted load balancer
# ##########################################################################
# http {
#     upstream backend {
#         server localhost:3001 weight=2;         # connection distributed based on server weight 
#         server localhost:3002 weight=5;
#         server localhost:3003 weight=3;
#         server localhost:3004;                  # default weight = 1
#     }
    
#     server {
#         listen 3000;
        
#         location / {
#             proxy_pass http://backend;
#         }
#     }
# }

# events {}



##########################################################################
# load balancing on a specified path
# ##########################################################################
# http {
#     upstream backend {
#         least_conn;
        
#         server localhost:3001;      # -! servers have to listen on path /test 
#         server localhost:3002;
#         server localhost:3003;
#         server localhost:3004;
#     }
    
#     server {
#         listen 3000;
        
#         location /test {            # load is balanced at this path
#             proxy_pass http://backend;
#         }
#     }
# }

# events {}



##########################################################################
# passive health chekck 
# ##########################################################################
# http {
#     upstream backend {
#         server localhost:3001;
#         server localhost:3002 max_fails=3 fail_timeout=1m;    # after 3 failed attempts nginx marks this server as unavailable for 1 minute
#     }
    
#     server {
#         listen 3000;
        
#         location / { 
#             proxy_pass http://backend;
#         }
#     }
# }

# events {}



##########################################################################
# active health chekck 
# ##########################################################################
# http {
#     upstream backend {
#         server localhost:3001;
#         server localhost:3002;
#         health_check;
#     }
    
#     server {
#         listen 3000;
        
#         location / { 
#             proxy_pass http://backend;
#         }
#     }
# }

# events {}



##########################################################################
# variables 
# ##########################################################################
# http {
#     server {
#         set $hw "Hello World";
        
#         listen 3000;
        
#         location / {
#             return 200 $hw;
#         }
#     }
# }

# events {}


##########################################################################
# variables map directive
# ##########################################################################
# http {
#     map $uri $return_value {      # this is basically a JavaScript case-like statement the $uri value is mapped based on the case to the $return_value
#         default "Hello World";
#         ~^/test "Test";
#         / "Root";
#     }

#     server {
        
#         listen 3000;
        
#         location / {
#             return 200 $return_value;
#         }
#     }
# }

# events {}



##########################################################################
# limiting http methods
# ##########################################################################
# http {
#     server {
#         listen 3000;
#         root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site";
        
#         location / {
#             limit_except GET {      # only the GET (and HEAD) http methods are allowed for this location
#                 deny all;
#             }
#         }
        
#     }
# }

# events {}



##########################################################################
# virtual hosting with the server_name directive
# ##########################################################################
# http {
#     server {    # on host test1:3000 or test2:3000 (or localhost:3000 <- default) this virtual server is triggered
#         listen 3000;
#         server_name test1 test2;
        
#         location / {
#             return 200 'respond to test1 or test2';
#         }
#     }
    
#     server {    # on host test3:3000 or test4:3000 (or localhost:3000 <- default) this virtual server is triggered
#         listen 3000;
#         server_name test3 test4;
        
#         location / {
#             return 200 'respond to test3 or test4';
#         }
#     }
# }

# events {}



# *#########################################################################
# compression
# ##########################################################################
# http {
#     gzip on;            # compresses (includes the header <mark>Content-Encoding gzip</mark>)
    
#     server { 
#         listen 3000;
#         root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site";
#     }
# }

# events {}



# *#########################################################################
# using nginx for ssl reverse proxy
# ##########################################################################
# http {
#     include /opt/homebrew/etc/nginx/mime.types;

#     server { 
#         listen 3000 ssl;
#         7 localhost;
        
#         ssl_certificate "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/srvCert.cer";
#         ssl_certificate_key "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/srvKey.pem";
        
#         root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site";
#     }
# }

# events {}



# *#########################################################################
# using nginx reverse proxy for ssl load balancer
# ##########################################################################
# http {
#     include /opt/homebrew/etc/nginx/mime.types;

#     upstream backend {
#         server localhost:3001;
#         server localhost:3002;
#     }

#     server {                                # https connection between the client and nginx 
#         listen 3000 ssl;
#         server_name localhost;
        
#         ssl_certificate "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/srvCert.cer";
#         ssl_certificate_key "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/srvKey.pem";
        
#         root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site";
        
#         location / {
#             proxy_pass http://backend;      # simple http connection betweenn backend servers
#         }
#     }
# }

# events {}



# *#########################################################################
# basic authentication
# ##########################################################################
# http {
#     include /opt/homebrew/etc/nginx/mime.types;
    
#     server {
#         listen 3000;
#         root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site";
        
#         auth_basic "HTTP Basic Authentication";
#         auth_basic_user_file "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/TEST/.htpasswd";
#     }
# }

# events {}




# *#########################################################################
# static caching
# ##########################################################################
http {
    proxy_cache_path '/home/pall/Documents/IT/my_knowledge_code_base/My Site/NGINX/cache' keys_zone=mycache:10m;
    proxy_cache_valid any 2m;     # for any request types (GET, POST, etc..) cache is valid for 2 minutes

    server {
        listen 3000;
        proxy_cache         mycache;            # valid for both virtual servers
        
        location / {
            proxy_pass http://localhost:3001;
        }

        location /test {
            proxy_pass http://localhost:3002;
        }
    }
}

events {}







# *#########################################################################
# geo {}
# ##########################################################################

# http {

#     geo $localhost_request {
#         default     'No';
#         127.0.0.1   'Yes';
#         ::1         'Yes';
#     }

#     server {
#         listen 3000;
#         location / {
#             return 200 $localhost_request;
#         }
#     }
# }

# events {}





    # access_log '/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/access.log';
    # error_log '/Users/apall/Documents/Personal/my_knowledge_code_base/My Site/NGINX/error.log';
    # access_log /dev/stdout;
    # error_log /dev/stderr;
