<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Streams </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Streams (ver 3.2) </h1>
    <p> Updated ( 2019-06-25 / 2019-07-23 )</p>
    <p class="sitenav"> <a href="../../index.html">MySite></a>
        <a href="../index.html">Node.js></a> Streams
    </p>
    <p class="subSite"><a href="Writable Streams/index.html"> Writable Streams > </a></p>
    <p class="subSite"><a href="Readable Streams/index.html"> Readable Streams > </a></p>
    <p class="subSite"><a href="Duplex and Transform Streams/index.html"> Duplex and Transform Streams > </a></p>
    <p class="subSite"><a href="Stream Implementers API/index.html"> Stream Implementers API > </a></p>
<table class="table">
<caption> Utility Methods </caption>
    <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
    </tr>
    <tr>
        <td> stream.finished(<strong>readable|writableStream</strong><i>, option:obj</i>, function(<i>err</i>)) </td>
        <td> - invokes the callback function when the writable|readable stream is no longer writable|readable <br>
             - invokes the callback function if the stream has experienced an error or a premature close <br>
             - thrown error is hadled by the callback function
            <span id="browserSupport" title="updated : 2019-07-23">
                <span><i class="fab fa-node-js"></i> 10.0.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> stream.pipeline(<strong>streamAny, streamAny</strong><i>, ...</i>, function(<i>err</i>)) </td>
        <td> - pipes the data through all the streams in the line <br>
             - callback function is invoked if the data is fully piped through the stream chain (otherwise it is not invoked) <br> 
             - callback function also fires when an error occurs <u>(can handle the thrown error)</u> 
            <span id="browserSupport" title="updated : 2019-07-23">
                <span><i class="fab fa-node-js"></i> 10.0.0 </span>
            </span>
        </td>
    </tr>
</table>
    <br>
<h2 style="color:green;"><u> Notes : </u></h2>
    <details class="example" id="notes">
    <summary> Notes :</summary>
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://nodejs.org/docs/latest/api/webstreams.html" target="_blank">Stream Nodejs docs (nodejs.com) </a></p>
<h2 style="color:green;"><u> Remember This : </u></h2>
    <p> - I tested to overflow a buffer and I expected some data loss but it never occured here [2019-06-28] </p>
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - the stream interface allows us to 'stream data' (sending <u>large data</u> chunk by chunk)  </p>
    <p> - in Node.js there are many built-in streams, but we also can create streams directly (which is rarely used) </p> 
    <p> - all Node.js built-in streams <u>operate exclusively on string, Buffer or Uint8Array</u></p>
    <p> - It is possible to create streams which can operate on any type of values <u>(except <mark>null</mark>)</u>, such streams operate in <u>object mode</u> (switching an existing stream to 'object mode' is NOT safe) </p>
    <p> - the stream stores the data in an internal Buffer (accessible by the <mark>writableBuffer</mark> and <mark>readableBuffer</mark> properties) </p>
    <p> - the Buffer size is defined by the <mark>highWaterMark</mark> option when the stream is created (normal streams size = bytes / streams in object mode size = number of objects) <u>we can pass larger data chunks than the buffer size (they will be stored in the memory) but it's not recommended!</u> </p>
<h2 class="headerExtra"><u> Utility methods </u></h2>
<h2 style="color:darkblue;"><u> the <mark>finished()</mark> / <mark>pipeline()</mark> methods </u></h2>
    <pre class="syntax">
SYNTAX :    const stream = require('stream');
            
            stream.finished(<strong>readable|writableStream</strong><i>, option:obj</i>, function(<i>err</i>))       // invokes the callback function when the writable|readable stream is no longer writable|readable 
                - <i>option:obj</i>                                                             invokes the callback function if the stream has experienced an error or a premature close 
                                                                                         thrown error is hadled by the callback function    
                    - error: <strong>bol</strong>                   // if set to <mark>false</mark> the callback function does not handle the thrown error by the stream (Default : <mark>true</mark>)
                    - writable: <strong>bol</strong>                // if set to <mark>false</mark> the callback fired even though the stream might be still writable (Default : <mark>true</mark>) <span style="color:orange;">[TESTED but I couldn't figure out how this works 2019-07-23]</span>   
                    - readable: <strong>bol</strong>                // if set to <mark>false</mark> the callback fired even though the stream might be still readable (Default : <mark>true</mark>) <span style="color:orange;">[TESTED but I couldn't figure out how this works 2019-07-23]</span>   
                    
            stream.pipeline(<strong>streamAny, streamAny</strong><i>, ...</i>, function(<i>err</i>))                 // pipes the data through all the streams in the line   
                                                                                         callback function is invoked if the data is fully piped through the stream chain (otherwise it is not invoked)   
                                                                                         callback function also fires when an error occurs <u>(can handle the thrown error)</u>   
    </pre>
    <pre>
    const stream = require("stream");
    const fs = require('fs');
    
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
    
    var duplexStream = new stream.Duplex({read(size){}, write(chunk, encode, callback){ callback(); }});
    var transformStream = new stream.PassThrough();
    
// finished() ------------------------------------------------------------------------
    readStream.pipe(writeStream);
    
    stream.finished(readStream, function(err){ err })                                 // callback is invoked when the stream is not readable any more (if an error occurs it can be handled here)   
    stream.finished(writeStream, {error:false}, function(){})                         // callback is invoked when the stream is not writable any more   // -! callback function does not hanlde any occured error in this case   
    
// pipeline() ------------------------------------------------------------------------
    stream.pipeline(readStream, transformStream, writeStream, function(err) {         // callback is invoked because the data can be piped from the'readStream' all the way to the 'writeStream'   
        err;                                                                          // -! if an error occurs the callback is invoked and the error is returned and handled in it (this is an awesome way to avoid registering an error listener to all streams)  
    });
    
    stream.pipeline(readStream, transformStream, duplexStream, writeStream, function(){ });  // callback is not invoked here because the 'duplexStream' does not transfer the data (data is still piped till the 'duplexStream' though)   
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> <mark>finished()</mark> TEST </u></h4>
    <pre style="margin-bottom:1px;">
    const stream = require('stream');
    const fs = require('fs');
    
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
    var writeStream2 = fs.createWriteStream('write.txt');
    
// test end writable -----------------------------------------------------------------
    stream.finished(writeStream, function(err){                                       // once the writable stream finishes writing the callback function is invoked  
        console.log( 'writable ended' );
    });
    
    writeStream.write('write some data');
    writeStream.end();
    
// test end readable -----------------------------------------------------------------
    stream.finished(readStream, function(err){                                        // once the readable stream finishes reading the callback function is invoked 
        console.log( 'readable ended' );
    });
    
    readStream.on('readable', function(){
        this.read();
    });
    
// threating errors -----------------------------------------------------------------
    stream.finished(writeStream2, {error:false}, err => {                             // we basically switched off the error handling feature here  
        console.log( err );                                                           // -> undefined 
    });
    writeStream2.on('error', err => {});                                              // we handle the thrown error here (because the 'finish()' method does not handle it)   
    
    writeStream2.write(21);                                                           // wrong data type given (stream is not in object mode)
    writeStream2.end();
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\01 finished() TEST> node main
        undefined                                                                     // writeStream2 'finish()' method 
        writable ended                                                                // writeStream 'finish()' method
        readable ended                                                                // readStream 'finish()' method
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\01 finished() TEST>    
    </pre>
<hr>
<!--------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>pipeline()</mark> TEST </u></h4>
    <pre style="margin-bottom:1px;">
    const stream = require('stream');   
    const fs = require('fs');
    
// piping data all the way through successfully the line -----------------------------------
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
    
    var passThrough = new stream.PassThrough();
    var transformStream = new stream.Transform({transform(chunk, encode, callback){ callback(null, chunk)}});
    
    stream.pipeline(readStream, passThrough, transformStream, writeStream, function(){
        console.log( 'PIPELINE 1 = data piped through successfully!' );               // callback function fires because the streams in the pipeline allows the data piping through all the way to the 'writeStream'   
    });
    
// data not piped through ------------------------------------------------------------------
    var readStream2 = fs.createReadStream('read2.txt');
    var writeStream2 = fs.createWriteStream('write2.txt');
    
    var passThrough2 = new stream.PassThrough();
    var duplexStream = new stream.Duplex({read(){}, write(chunk, encode, callback){ callback()}});
    
    stream.pipeline(readStream2, passThrough2, duplexStream, writeStream2, function(){ 
        console.log( 'PIPELINE 2 = data piped through successfully!' );               // callback function does NOT fire because the 'duplexStream' prevent the data passing through   
    });                                                                               // -! data is still piped till 'duplexStream' but not any further
    
// error handling --------------------------------------------------------------------------
    var readStream3 = fs.createReadStream('read3.txt');
    var writeStream3 = fs.createWriteStream('write3.txt');
    
    var passThrough3 = new stream.PassThrough();
    
    stream.pipeline(readStream3, passThrough3, writeStream3, function(err){
        console.log( 'an error occured = ' + err.name );                              // the thrown error is handled here 
    });
    
    passThrough3.write(21);                                                           // passing a non string or Buffer data throws an error 
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\02 pipeline() TEST> node main
        an error occured = TypeError                                                  // handled error 
        PIPELINE 1 = data piped through successfully!                                 // successful pipeline callback message 
                                                                                      // pipeline 2 callback is not invoked because the data isn't piped throug and no errors are thrown eigther 
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\02 pipeline() TEST>    
    </pre>
</details>
    
    <br><br>
</body>
</html>