<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Streams </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Streams (ver 3.2) </h1>
    <p> Updated ( 2019-06-25 / 2019-07-23 / 2024-03-11 )</p>
    <p class="sitenav"> <a href="../../index.html">MySite></a>
        <a href="../index.html">Node.js></a> Streams
    </p>
    <p class="subSite"><a href="Readable Streams/index.html"> Readable Streams > </a></p>
    <p class="subSite"><a href="Writable Streams/index.html"> Writable Streams > </a></p>
    <p class="subSite"><a href="Duplex and Transform Streams/index.html"> Duplex and Transform Streams > </a></p>
    <p class="subSite"><a href="Stream Implementers API/index.html"> Stream Implementers API > </a></p>
<table class="table">
<caption> Utility Methods </caption>
    <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
    </tr>
    <tr>
        <td> stream.finished(<strong>readable|writableStream</strong><i>, option:obj</i>, function(<i>err</i>)) </td>
        <td> - invokes the callback function when the writable|readable stream is no longer writable|readable <br>
             - invokes the callback function if the stream has experienced an error or a premature close <br>
             - thrown error is hadled by the callback function
            <span id="browserSupport" title="updated : 2019-07-23">
                <span><i class="fab fa-node-js"></i> 10.0.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> stream.pipeline(<strong>streamAny, streamAny</strong><i>, ...</i>, function(<i>err</i>)) </td>
        <td> - pipes the data through all the streams in the line <br>
             - callback function is invoked if the data is fully piped through the stream chain (otherwise it is not invoked) <br> 
             - callback function also fires when an error occurs <u>(can handle the thrown error)</u> 
            <span id="browserSupport" title="updated : 2019-07-23">
                <span><i class="fab fa-node-js"></i> 10.0.0 </span>
            </span>
        </td>
    </tr>
</table>
    <br>
<h2 style="color:green;"><u> Notes : </u></h2>
    <details class="example" id="notes">
    <summary> Notes :</summary>
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://nodejs.org/docs/latest/api/stream.html" target="_blank">Stream Nodejs docs (nodejs.com) </a></p>
<h2 style="color:green;"><u> Remember This : </u></h2>
    <p> - I tested to overflow a buffer and I expected some data loss but it never occured here [2019-06-28] </p>
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - the stream moduel provides an abstrat iinterface for streaming data (writing/consuming <u>large data</u> chunk by chunk) </p>
    <p> - a stream can be Readable, Writable or both (Duplex, Transform), all node streams are instance of <mark>EventEmitter</mark> </p>
    <p> - almost all node APIs use streams (http socker, file, etc...), but we also can implement our own (rarely used) </p>
    <p> - streams can operate on: </p>
    <p class="indent-lv1"> - string, <mark>Buffer</mark> or <mark>Uint8Array</mark> (default) </p>
    <p class="indent-lv1"> - object mode (object instead serialized data), all data type supported <u>except null</u> <u>(switching an existing stream into object mode is not safe!)</u> </p>
    <h2 class="header"> Buffering </h2>
    <p> - streams use an internal buffer for temporarily store data, the limit of this buffer is described as <mark>highWaterMark</mark>, its size indicates the stored bytes (or stored objects in object mode) (Duplex and Transform streams have 2 buffers (one on each side) </p>
    <p> - the <mark>highWaterMark</mark> is a treshold <u>not a hard memory limiter</u>, so the buffer can be fored to store more data (risky game) </p>
    <p> - behaviour on <mark>highWaterMark</mark> limit overflow: </p>
    <p class="indent-lv1"> - ReadableStream -> stop reading the underlying resource untill buffer space freed up </p>
    <p class="indent-lv1"> - WritableStream -> the <mark><reqval>readableStream</reqval>.read()</mark> returns <mark>false</mark> (returns <mark>true</mark> if treshold is under the limit again) </p>
    <hr>
    <!---------------------------------------------------------------------------------------------------------->
    
    
    
    
    
    <!--
    
    
    
    - I go through this once readable & writable is finished
        - stream.Readable.from()
            - creates a readable stream from iteraltor
        - stream.Duplex.from()
            - creates a duplex stream
        - stream.addAbortSignal()
            - attaches an abort signal so the stream (same effect as .destroy(new AbortError()) call)
        
        - stream.getDefaultHighWater
            - also set method -> document it!
    
    
    - stream Promises API
    v15.0.0
    
    - provides a promise api aproach rather than using callbacks (does the same but with Promises)
    - finised() (promise)
    - pipeline() (promise)
    
    
    
    - writable stream
        - abstraction for destination to which the data is written
        
    WritableStrea.closed
        - returns true if the close event has been emitted
    WritableStrea.closed
        - returns true if strea.destroy() has been called
    
    
    
    - update readableFlowing property
    - async interator reading data -> document this (imporatnt)
    Creating readable streams with async generators
    https://nodejs.org/docs/latest/api/stream.html#piping-to-writable-streams-from-async-iterators
    
    - for backward compatibility reason removing the 'drain' event will not pauses the stream

    ----------------------------------------------------------------------------
    ----------------------------------------------------------------------------
    ----------------------------------------------------------------------------
    object mode ?
    
    -->
    
    <!--
    
      <h2 style="color:darkblue;"><u> <mark>from()</mark> method </u></h2>
  <pre class="syntax">
SYNTAX :    const stream = require('stream');
            
            stream.Readable.from(<strong>iterableObj</strong><i>, option:obj</i>)                      // returns a readable stream out of an iteralbe object <u>(the created stream is in object mode by default)</u>
                - <strong>iterableObj</strong> : object impelementing the <mark>Symbol.iterator</mark> or <mark>Symbol.asyncIterator</mark> protocol   
                - <i>option:obj</i> 
                    - highWaterMark: <strong>nr</strong>                // sets the buffer size (Default : 16384 / 16 in object mode)
                    - encoding: <strong>str</strong>                    // decode the Buffers to the specified string (Default : null) 
                    - objectMode: <strong>bol</strong>                  // sets the stream in object mode (Default : true)
                    - autoDestroy: <strong>bol</strong>                 // stream calls the <mark>destroy()</mark> method on itself after ending (Default: false)
    </pre>
  <pre>
    const stream = require("stream");
    
    var str = 'myString';                                                      // string is not an object but we still can use it because it has the 'Symbol.iterator' protocol 
    var arr = [1, 'two', true];
    
    async function* generateData() {                                           // asynchronous generator function (generates data asynchronously)
        yield 43;
        yield 'fourty two';
        yield false;
    }
    
    var readString1 = stream.Readable.from(str, {objectMode:false});           // -! stream is not operating in object mode
    var readString2 = stream.Readable.from(arr);
    var readString3 = stream.Readable.from(generateData());
    </pre>
  <details class="example">
    <summary> Example : </summary>
    <h3 style="color:darkblue;"><u> <mark>from()</mark> TEST </u></h3>
    <p> - delayed the event listeners in order to better see the result </p>
    <pre style="margin-bottom:1px;">
    const stream = require('stream');
    
    async function* generate() {                                               // asynchronously generated data 
        yield 'kicsi';
        yield 'kutya';
        yield 'tarka'
    }
    
    var readStream = stream.Readable.from(["kicsi", "kutya", "tarka"], {objectMode:false});
    setTimeout(()=>{
        console.log("// readStream ----------------------------------");
        readStream.on('data', chunk => console.log( chunk.toString() ));
    }, 0);
    
    var readStream2 = stream.Readable.from(generate(), {objectMode:false});
    setTimeout(()=>{
        console.log("// readStream2 ---------------------------------");
        readStream2.on('data', chunk => console.log( chunk.toString() ));
    }, 1000);
    
    var readStream3 = stream.Readable.from(generate(), {objectMode:false});
    setTimeout(()=>{
        console.log("// readStream3 ---------------------------------");
        readStream3.on('readable', () => console.log(String(readStream3.read()) ));
    }, 2000);
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\readable streams\13 from() TEST>node main
        // readStream ----------------------------------
        kicsi
        kutya
        tarka
        // readStream2 ---------------------------------
        kicsi
        kutya
        tarka
        // readStream3 ---------------------------------
        kicsikutyatarka                                                        // the 'readable' event listener buffers as many data as possible in the buffer memory at once 
        null                                                                   // last call 
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\readable streams\13 from() TEST>    </pre>
  </details>

    
    
    -->
    
    
    
<h2 class="headerExtra"><u> Utility methods </u></h2>
<h2 style="color:darkblue;"><u> the <mark>finished()</mark> / <mark>pipeline()</mark> methods </u></h2>
    <pre class="syntax">
    const stream = require('stream');
            
    stream.finished(<strong>readable|writableStream</strong><i>, option:obj</i>, function(<i>err</i>))       // invokes the callback function when the writable|readable stream is no longer writable|readable 
                - <i>option:obj</i>                                                             invokes the callback function if the stream has experienced an error or a premature close 
                                                                                         thrown error is hadled by the callback function    
                    - error: <strong>bol</strong>                   // if set to <mark>false</mark> the callback function does not handle the thrown error by the stream (Default : <mark>true</mark>)
                    - writable: <strong>bol</strong>                // if set to <mark>false</mark> the callback fired even though the stream might be still writable (Default : <mark>true</mark>) <span style="color:orange;">[TESTED but I couldn't figure out how this works 2019-07-23]</span>   
                    - readable: <strong>bol</strong>                // if set to <mark>false</mark> the callback fired even though the stream might be still readable (Default : <mark>true</mark>) <span style="color:orange;">[TESTED but I couldn't figure out how this works 2019-07-23]</span>   
                    
            stream.pipeline(<strong>streamAny, streamAny</strong><i>, ...</i>, function(<i>err</i>))                 // pipes the data through all the streams in the line   
                                                                                         callback function is invoked if the data is fully piped through the stream chain (otherwise it is not invoked)   
                                                                                         callback function also fires when an error occurs <u>(can handle the thrown error)</u>   
    </pre>
    <pre>
    const stream = require("stream");
    const fs = require('fs');
    
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
    
    var duplexStream = new stream.Duplex({read(size){}, write(chunk, encode, callback){ callback(); }});
    var transformStream = new stream.PassThrough();
    
// finished() ------------------------------------------------------------------------
    readStream.pipe(writeStream);
    
    stream.finished(readStream, function(err){ err })                                 // callback is invoked when the stream is not readable any more (if an error occurs it can be handled here)   
    stream.finished(writeStream, {error:false}, function(){})                         // callback is invoked when the stream is not writable any more   // -! callback function does not hanlde any occured error in this case   
    
// pipeline() ------------------------------------------------------------------------
    stream.pipeline(readStream, transformStream, writeStream, function(err) {         // callback is invoked because the data can be piped from the'readStream' all the way to the 'writeStream'   
        err;                                                                          // -! if an error occurs the callback is invoked and the error is returned and handled in it (this is an awesome way to avoid registering an error listener to all streams)  
    });
    
    stream.pipeline(readStream, transformStream, duplexStream, writeStream, function(){ });  // callback is not invoked here because the 'duplexStream' does not transfer the data (data is still piped till the 'duplexStream' though)   
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> <mark>finished()</mark> TEST </u></h4>
    <pre style="margin-bottom:1px;">
    const stream = require('stream');
    const fs = require('fs');
    
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
    var writeStream2 = fs.createWriteStream('write.txt');
    
// test end writable -----------------------------------------------------------------
    stream.finished(writeStream, function(err){                                       // once the writable stream finishes writing the callback function is invoked  
        console.log( 'writable ended' );
    });
    
    writeStream.write('write some data');
    writeStream.end();
    
// test end readable -----------------------------------------------------------------
    stream.finished(readStream, function(err){                                        // once the readable stream finishes reading the callback function is invoked 
        console.log( 'readable ended' );
    });
    
    readStream.on('readable', function(){
        this.read();
    });
    
// threating errors -----------------------------------------------------------------
    stream.finished(writeStream2, {error:false}, err => {                             // we basically switched off the error handling feature here  
        console.log( err );                                                           // -> undefined 
    });
    writeStream2.on('error', err => {});                                              // we handle the thrown error here (because the 'finish()' method does not handle it)   
    
    writeStream2.write(21);                                                           // wrong data type given (stream is not in object mode)
    writeStream2.end();
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\01 finished() TEST> node main
        undefined                                                                     // writeStream2 'finish()' method 
        writable ended                                                                // writeStream 'finish()' method
        readable ended                                                                // readStream 'finish()' method
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\01 finished() TEST>    
    </pre>
<hr>
<!--------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>pipeline()</mark> TEST </u></h4>
    <pre style="margin-bottom:1px;">
    const stream = require('stream');   
    const fs = require('fs');
    
// piping data all the way through successfully the line -----------------------------------
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
    
    var passThrough = new stream.PassThrough();
    var transformStream = new stream.Transform({transform(chunk, encode, callback){ callback(null, chunk)}});
    
    stream.pipeline(readStream, passThrough, transformStream, writeStream, function(){
        console.log( 'PIPELINE 1 = data piped through successfully!' );               // callback function fires because the streams in the pipeline allows the data piping through all the way to the 'writeStream'   
    });
    
// data not piped through ------------------------------------------------------------------
    var readStream2 = fs.createReadStream('read2.txt');
    var writeStream2 = fs.createWriteStream('write2.txt');
    
    var passThrough2 = new stream.PassThrough();
    var duplexStream = new stream.Duplex({read(){}, write(chunk, encode, callback){ callback()}});
    
    stream.pipeline(readStream2, passThrough2, duplexStream, writeStream2, function(){ 
        console.log( 'PIPELINE 2 = data piped through successfully!' );               // callback function does NOT fire because the 'duplexStream' prevent the data passing through   
    });                                                                               // -! data is still piped till 'duplexStream' but not any further
    
// error handling --------------------------------------------------------------------------
    var readStream3 = fs.createReadStream('read3.txt');
    var writeStream3 = fs.createWriteStream('write3.txt');
    
    var passThrough3 = new stream.PassThrough();
    
    stream.pipeline(readStream3, passThrough3, writeStream3, function(err){
        console.log( 'an error occured = ' + err.name );                              // the thrown error is handled here 
    });
    
    passThrough3.write(21);                                                           // passing a non string or Buffer data throws an error 
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\02 pipeline() TEST> node main
        an error occured = TypeError                                                  // handled error 
        PIPELINE 1 = data piped through successfully!                                 // successful pipeline callback message 
                                                                                      // pipeline 2 callback is not invoked because the data isn't piped throug and no errors are thrown eigther 
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\02 pipeline() TEST>    
    </pre>
</details>
    
    <br><br>
</body>
</html>